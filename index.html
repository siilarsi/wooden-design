<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wooden Design</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(#d9dee8, #f3f4f8);
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.95);
        padding: 16px;
        border-radius: 8px;
        max-width: 300px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      #ui section {
        margin-bottom: 12px;
      }
      #ui h2 {
        margin: 0 0 4px;
        font-size: 1em;
      }
      #viewer {
        width: 80vw;
        height: 80vh;
        border: 2px solid #444;
        box-sizing: border-box;
        position: relative;
        border-radius: 8px;
        background: #fff;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      #eventLog {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 320px;
        max-height: 25vh;
        overflow-y: auto;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        padding: 8px;
        font-size: 0.8em;
        border-radius: 4px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }
      #dropArea {
        border: 2px dashed #888;
        padding: 20px;
        text-align: center;
        margin-top: 10px;
        border-radius: 4px;
        transition: background 0.3s;
      }
      #dropArea.hover {
        background: #eef;
      }
      #fileInput {
        margin-top: 10px;
        width: 100%;
      }
      #instructions {
        font-size: 0.9em;
        margin-bottom: 10px;
      }
      select {
        width: 100%;
      }
      button {
        margin-top: 10px;
        width: 100%;
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        background: #007bff;
        color: #fff;
        cursor: pointer;
        font-size: 1em;
      }
      button:hover {
        background: #0056b3;
      }
      .help {
        display: inline-block;
        width: 16px;
        height: 16px;
        line-height: 16px;
        text-align: center;
        border-radius: 50%;
        background: #007bff;
        color: #fff;
        font-size: 12px;
        margin-left: 4px;
        cursor: help;
        position: relative;
      }
      .help::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: 6px 8px;
        border-radius: 4px;
        white-space: normal;
        max-width: 320px;
        font-size: 0.85em;
        display: none;
        z-index: 100;
      }
      .help:hover::after {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="viewer">
      <div id="eventLog"></div>
    </div>
    <div id="ui">
      <p id="instructions">
        Select a plank model and apply your texture using drag &amp; drop or the
        <strong>Upload</strong> button. Detailed loading logs are shown in the
        browser console.
      </p>
      <section>
        <h2>Model<span class="help" data-tooltip="Choose which wood plank geometry to view">?</span></h2>
        <select id="modelSelect" aria-label="Model selection">
          <option value="models/plank1.gltf">Plank 1</option>
          <option value="models/plank2.gltf">Plank 2</option>
        </select>
        <span class="help" data-tooltip="Select a predefined 3D plank model to preview">?</span>
      </section>
      <section>
        <h2>Texture<span class="help" data-tooltip="Upload a PNG or JPEG image to use as a texture. It will wrap onto the 3D plank.">?</span></h2>
        <div id="dropArea" aria-label="Drop texture" role="button">
          Drag &amp; Drop Texture Here
        </div>
        <span class="help" data-tooltip="Drop an image file here and it will immediately show on the plank">?</span>
        <input
          type="file"
          id="fileInput"
          accept="image/*"
          aria-label="Upload texture"
        />
        <span class="help" data-tooltip="Choose an image file (PNG or JPEG) from your computer">?</span>
      </section>
      <section>
        <h2>Finish<span class="help" data-tooltip="Select a preset or keep custom values in the sliders">?</span></h2>
        <select id="finishSelect" aria-label="Finish presets">
          <option value="custom">Custom</option>
          <option value="matte">Matte</option>
          <option value="satin">Satin</option>
          <option value="gloss">Gloss</option>
        </select>
        <span class="help" data-tooltip="Applies common finish settings to the material">?</span>
      </section>
      <button id="copyLink" aria-label="Copy shareable link">
        Copy Link<span class="help" data-tooltip="Copies a URL with your current settings so you can share your design">?</span>
      </button>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js";
      import { OrbitControls } from "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js";
      import { buildQuery, debounce } from "./src/utils.js";
      import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

      function logEvent(msg) {
        const box = document.getElementById('eventLog');
        const div = document.createElement('div');
        div.textContent = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
        console.log('[Viewer]', msg);
      }

      logEvent('Wooden Design viewer initialized');

      let scene, camera, renderer, controls, model;
      let firstFrame = true;
      const params = {
        model: "models/plank1.gltf",
        roughness: 0.5,
        metalness: 0.0,
        clearcoat: 0,
        clearcoatRoughness: 0,
        specularIntensity: 1,
        specularColor: "#111111",
        sheenColor: "#000000",
        sheenRoughness: 0.5,
        anisotropy: 0,
        anisotropyRotation: 0,
        finish: "custom",
      };

      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has("model")) params.model = urlParams.get("model");
      if (urlParams.has("roughness"))
        params.roughness = parseFloat(urlParams.get("roughness"));
      if (urlParams.has("metalness"))
        params.metalness = parseFloat(urlParams.get("metalness"));
      if (urlParams.has("clearcoat"))
        params.clearcoat = parseFloat(urlParams.get("clearcoat"));
      if (urlParams.has("clearcoatRoughness"))
        params.clearcoatRoughness = parseFloat(
          urlParams.get("clearcoatRoughness"),
        );
      if (urlParams.has("specularIntensity"))
        params.specularIntensity = parseFloat(
          urlParams.get("specularIntensity"),
        );
      if (urlParams.has("specularColor"))
        params.specularColor = urlParams.get("specularColor");
      if (urlParams.has("sheenColor"))
        params.sheenColor = urlParams.get("sheenColor");
      if (urlParams.has("sheenRoughness"))
        params.sheenRoughness = parseFloat(urlParams.get("sheenRoughness"));
      if (urlParams.has("anisotropy"))
        params.anisotropy = parseFloat(urlParams.get("anisotropy"));
      if (urlParams.has("anisotropyRotation"))
        params.anisotropyRotation = parseFloat(
          urlParams.get("anisotropyRotation"),
        );

      init();
      document.getElementById("modelSelect").value = params.model;
      document.getElementById("finishSelect").value = params.finish;
      loadModel(params.model);

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaaaaa);
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          100,
        );
        camera.position.set(0, 2, 5);

        const container = document.getElementById("viewer");
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        logEvent('Renderer created at ' + renderer.domElement.width + 'x' + renderer.domElement.height);
        logEvent('WebGL version: ' + (renderer.capabilities.isWebGL2 ? 'WebGL2' : 'WebGL1'));

        controls = new OrbitControls(camera, renderer.domElement);
        controls.update();
        logEvent('Camera initialized at ' + camera.position.toArray().join(', '));

        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        scene.add(light);

        window.addEventListener("resize", onWindowResize);
        animate();
      }

      function onWindowResize() {
        const container = document.getElementById("viewer");
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        logEvent('Resized viewer to ' + container.clientWidth + 'x' + container.clientHeight);
      }
      const updateURL = debounce(() => {
        const q = buildQuery({
          model: params.model,
          roughness: params.roughness,
          metalness: params.metalness,
          clearcoat: params.clearcoat,
          clearcoatRoughness: params.clearcoatRoughness,
          specularIntensity: params.specularIntensity,
          specularColor: params.specularColor,
          sheenColor: params.sheenColor,
          sheenRoughness: params.sheenRoughness,
          anisotropy: params.anisotropy,
          anisotropyRotation: params.anisotropyRotation,
        });
        history.replaceState(null, "", `?${q}`);
      }, 200);

      function loadModel(path) {
        const loader = new GLTFLoader();
        logEvent('Loading model ' + path);
        loader.load(
          path,
          (gltf) => {
            if (model) {
              scene.remove(model);
            }
            model = gltf.scene;
            model.traverse((child) => {
              if (child.isMesh) {
                const mat = new THREE.MeshPhysicalMaterial({
                  map: child.material.map,
                  roughness: params.roughness,
                  metalness: params.metalness,
                  clearcoat: params.clearcoat,
                  clearcoatRoughness: params.clearcoatRoughness,
                  specularIntensity: params.specularIntensity,
                  specularColor: new THREE.Color(params.specularColor),
                 sheenColor: new THREE.Color(params.sheenColor),
                 sheenRoughness: params.sheenRoughness,
                  anisotropy: params.anisotropy,
                  anisotropyRotation: params.anisotropyRotation,
                });
                child.material = mat;
              }
            });
            scene.add(model);
            const box = new THREE.Box3().setFromObject(model);
            const sphere = box.getBoundingSphere(new THREE.Sphere());
            logEvent('Model loaded with bounding box ' +
              box.min.toArray().join(',') + ' to ' + box.max.toArray().join(','));
            logEvent('Bounding sphere center ' + sphere.center.toArray().join(',') + ' radius ' + sphere.radius.toFixed(2));
            logEvent('Scene now has ' + scene.children.length + ' objects');
            updateURL();
          },
          undefined,
          (err) => {
            logEvent('Failed to load model ' + err.message);
            console.error('Failed to load model', err);
          },
        );
      }

      function animate() {
        requestAnimationFrame(animate);
        if (firstFrame) {
          logEvent('First frame rendered');
          firstFrame = false;
        }
        renderer.render(scene, camera);
      }

      document.getElementById("modelSelect").addEventListener("change", (e) => {
        params.model = e.target.value;
        loadModel(params.model);
      });

      document
        .getElementById("finishSelect")
        .addEventListener("change", (e) => {
          params.finish = e.target.value;
          if (params.finish === "matte") {
            params.roughness = 0.9;
            params.metalness = 0.0;
          } else if (params.finish === "satin") {
            params.roughness = 0.5;
            params.metalness = 0.0;
          } else if (params.finish === "gloss") {
            params.roughness = 0.1;
            params.metalness = 0.0;
          }
          roughCtrl.setValue(params.roughness);
          metalCtrl.setValue(params.metalness);
          updateMaterials();
        });

      const textureLoader = new THREE.TextureLoader();
      const dropArea = document.getElementById("dropArea");
      const fileInput = document.getElementById("fileInput");

      function applyTexture(file) {
        if (!file) return;
        const url = URL.createObjectURL(file);
        logEvent('Loading texture ' + file.name);
        textureLoader.load(
          url,
          (tex) => {
            logEvent('Texture size ' + tex.image.width + 'x' + tex.image.height);
            if (model) {
              model.traverse((child) => {
                if (child.isMesh) {
                  child.material.map = tex;
                  child.material.needsUpdate = true;
                }
              });
            }
            URL.revokeObjectURL(url);
            updateMaterials();
            logEvent('Texture applied to model');
          },
          undefined,
          (err) => {
            logEvent('Failed to load texture ' + err.message);
            console.error('Failed to load texture', err);
          },
        );
      }

      // Prevent the browser from opening files when dropped outside the drop zone
      ["dragenter", "dragover", "drop"].forEach((evt) => {
        window.addEventListener(evt, (e) => {
          e.preventDefault();
        });
      });

      dropArea.addEventListener("dragenter", (e) => {
        e.preventDefault();
        dropArea.classList.add("hover");
      });
      dropArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropArea.classList.add("hover");
      });
      dropArea.addEventListener("dragleave", () => {
        dropArea.classList.remove("hover");
      });
      dropArea.addEventListener("drop", (e) => {
        e.preventDefault();
        dropArea.classList.remove("hover");
        const file = e.dataTransfer.files[0];
        applyTexture(file);
      });

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        applyTexture(file);
        fileInput.value = "";
      });

      const gui = new GUI();
      const roughCtrl = gui
        .add(params, "roughness", 0, 1, 0.01)
        .onChange(updateMaterials);
      const metalCtrl = gui
        .add(params, "metalness", 0, 1, 0.01)
        .onChange(updateMaterials);
      const ccCtrl = gui
        .add(params, "clearcoat", 0, 1, 0.01)
        .onChange(updateMaterials);
      const ccrCtrl = gui
        .add(params, "clearcoatRoughness", 0, 1, 0.01)
        .onChange(updateMaterials);
      const specCtrl = gui
        .add(params, "specularIntensity", 0, 2, 0.01)
        .onChange(updateMaterials);
      const specColorCtrl = gui
        .addColor(params, "specularColor")
        .onChange(updateMaterials);
      const sheenColorCtrl = gui
        .addColor(params, "sheenColor")
        .onChange(updateMaterials);
      const sheenRoughCtrl = gui
        .add(params, "sheenRoughness", 0, 1, 0.01)
        .onChange(updateMaterials);
      const anisoCtrl = gui
        .add(params, "anisotropy", 0, 1, 0.01)
        .onChange(updateMaterials);
      const anisoRotCtrl = gui
        .add(params, "anisotropyRotation", 0, Math.PI * 2, 0.01)
        .onChange(updateMaterials);

      roughCtrl.setValue(params.roughness);
      metalCtrl.setValue(params.metalness);
      ccCtrl.setValue(params.clearcoat);
      ccrCtrl.setValue(params.clearcoatRoughness);
      specCtrl.setValue(params.specularIntensity);
      specColorCtrl.setValue(params.specularColor);
      sheenColorCtrl.setValue(params.sheenColor);
      sheenRoughCtrl.setValue(params.sheenRoughness);
      anisoCtrl.setValue(params.anisotropy);
      anisoRotCtrl.setValue(params.anisotropyRotation);

        function updateMaterials() {
          if (model) {
            model.traverse((child) => {
              if (child.isMesh) {
                Object.assign(child.material, {
                  roughness: params.roughness,
                  metalness: params.metalness,
                  clearcoat: params.clearcoat,
                  clearcoatRoughness: params.clearcoatRoughness,
                  specularIntensity: params.specularIntensity,
                  specularColor: new THREE.Color(params.specularColor),
                  sheenColor: new THREE.Color(params.sheenColor),
                  sheenRoughness: params.sheenRoughness,
                  anisotropy: params.anisotropy,
                  anisotropyRotation: params.anisotropyRotation,
                });
              }
            });
            logEvent('Updated material parameters ' + JSON.stringify(params));
          }
          updateURL();
        }

      document
        .getElementById("copyLink")
        .addEventListener("click", async () => {
          updateURL();
          try {
            await navigator.clipboard.writeText(window.location.href);
            alert("Link copied to clipboard");
          } catch (err) {
            console.error(err);
          }
        });
    </script>
  </body>
</html>
